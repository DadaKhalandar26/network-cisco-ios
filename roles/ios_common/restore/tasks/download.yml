---
# ---------------------------------------------------------
# STEP 1 — Ensure download directory exists
# ---------------------------------------------------------
- name: Ensure download directory exists on controller
  file:
    path: "{{ download_dest_dir | default('/tmp') }}"
    state: directory
    mode: "01777"
  delegate_to: localhost

# ---------------------------------------------------------
# STEP 2 — List files from SFTP
# ---------------------------------------------------------
- name: List backup files on SFTP server (AWX-safe)
  ansible.builtin.shell: >
    printf "cd {{ sftp_path | default('/ios/backups/') }}\nls -1\nbye\n" |
    sshpass -p '{{ sftp_password }}' sftp
    -oBatchMode=no
    -oStrictHostKeyChecking=no
    -oUserKnownHostsFile=/dev/null
    {{ sftp_username }}@{{ sftp_host }}
  register: sftp_list
  delegate_to: localhost
  changed_when: false

- debug:
    var: sftp_list.stdout_lines

# ---------------------------------------------------------
# STEP 3 — Extract clean .cfg filenames
# ---------------------------------------------------------
- name: Flatten stdout_lines
  set_fact:
    sftp_raw: "{{ sftp_list.stdout_lines | default([]) | list }}"

- name: Tokenize output
  set_fact:
    sftp_tokens: >-
      {{ (sftp_raw
          | map('split')
          | list
          | sum(start=[])
          | map('trim')
          | reject('equalto','')
          | list) }}

- name: Keep only .cfg files
  set_fact:
    cfg_files: "{{ sftp_tokens | select('search','\\.cfg$') | list }}"

- debug:
    var: cfg_files

# ---------------------------------------------------------
# STEP 4 — Case-insensitive hostname prefix
# ---------------------------------------------------------
- name: Normalize hostname (strip FQDN + lowercase)
  set_fact:
    host_prefix: "{{ inventory_hostname.split('.')[0] | lower }}"

- name: Lowercase filenames
  set_fact:
    cfg_lower: "{{ cfg_files | map('lower') | list }}"

- debug:
    var: cfg_lower

# ---------------------------------------------------------
# STEP 5 — AWX-PROOF FILTERING (NO JINJA FILTERS)
# ---------------------------------------------------------
- name: Initialize empty list for matching files
  set_fact:
    matching_files: []

- name: Append matching files (AWX-proof loop)
  set_fact:
    matching_files: "{{ matching_files + [ item ] }}"
  loop: "{{ cfg_lower }}"
  when:
    - item.startswith(host_prefix + '-')
    - item.endswith('.cfg')

- debug:
    var: matching_files

- name: Fail if no backup found
  fail:
    msg: "No backup found for {{ inventory_hostname }} (prefix={{ host_prefix }})"
  when: matching_files | length == 0

# ---------------------------------------------------------
# STEP 6 — Select latest backup
# ---------------------------------------------------------
- name: Select latest backup
  set_fact:
    latest_backup: "{{ matching_files | sort | last }}"

- debug:
    var: latest_backup

# ---------------------------------------------------------
# STEP 7 — Download file
# ---------------------------------------------------------
- name: Download latest backup file
  ansible.builtin.shell: >
    printf "cd {{ sftp_path | default('/ios/backups/') }}\nget {{ latest_backup }} {{ download_dest_dir | default('/tmp') }}/{{ latest_backup }}\nbye\n" |
    sshpass -p '{{ sftp_password }}' sftp
    -oBatchMode=no
    -oStrictHostKeyChecking=no
    -oUserKnownHostsFile=/dev/null
    {{ sftp_username }}@{{ sftp_host }}
  register: download_status
  delegate_to: localhost
  changed_when: "'Fetching' in download_status.stdout"

- name: Confirm file exists
  stat:
    path: "{{ download_dest_dir | default('/tmp') }}/{{ latest_backup }}"
  register: downloaded_stat
  delegate_to: localhost

- debug:
    msg:
      - "Downloaded: {{ downloaded_stat.stat.exists }}"
      - "Path: {{ download_dest_dir | default('/tmp') }}/{{ latest_backup }}"
